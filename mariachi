#!/usr/local/bin/perl -w
use strict;
use Template;
use Time::HiRes qw( gettimeofday tv_interval );

my $start = [gettimeofday];

my $maildir = shift || die "need an input maildir";
my $output = shift || die "where do we put them?";

my @mails = map {
    open my $fh, "<$_" or die "open: '$_' $!";
    Message->new($fh);
} <$maildir/cur/*>, <$maildir/new/*>;

# some messages have been near mail2news gateways, which means that
# some message ids get munged like so: <$group/$message_id>

# this should clean that up
my %names;
for my $mail (@mails) {
    next; # but it doesn't, we lose messages from the index?
    for (qw( references in_reply_to )) {
        my $hdr = $mail->$_() or next;
        my $before = $hdr;
        $hdr =~ s{<[^>]*?/}{<}g or next;
        #print "$_ $before$_: $hdr";
        $mail->$_($hdr);
    }
}

print scalar @mails, " messages loaded in ", tv_interval( $start )," seconds\n";
$start = [gettimeofday];

my $threader = Mail::Thread::Mariachi->new( @mails );
$threader->thread;

$_->order_children for $threader->rootset;

print "and threaded in ", tv_interval( $start ), " seconds\n";

$start = [gettimeofday];

my $tt = Template->new( RECURSION => 1 );


$tt->process('index.tt2',
             { threads => [ $threader->sorted_rootset ] },
             "$output/index.html") or die $tt->error;

for my $mail (@mails) {
    $tt->process('message.tt2',
                 { thread  => find_root_thread($threader, $mail),
                   message => $mail,
                 },
                 "$output/".$mail->filename) or die $tt->error;
}

print "output generation took ", tv_interval( $start ), " seconds\n";

exit 0;

sub find_root_thread {
    my $self = shift;
    my $mail = shift;
    for my $cont ($self->rootset) {
        return $cont if $cont->find_message_id( $self->_msgid($mail) );
    }
}

package Mail::Thread::Mariachi;
use base 'Mail::Thread';
use Date::Parse qw(str2time);

sub _container_class { "Mail::Thread::Container::Mariachi" }

sub sorted_rootset {
    my $self = shift;
    _sort( $self->rootset );
}

sub _sort {
    return map {
        $_->[0]
    } sort {
        $a->[1] <=> $b->[1]
    } map {
        [ $_ => eval { str2time $_->topmost->message->date } || 0 ]
    } @_;
}

package Mail::Thread::Container::Mariachi;
use base 'Mail::Thread::Container';

sub order_children {
    my $self = shift;

    # go depth first
    eval { $self->child->order_children };
    eval { $self->next->order_children };

    my @neworder = Mail::Thread::Mariachi::_sort( $self->children );

    my $walk = $self->child( shift @neworder );
    while (scalar @neworder) {
        $walk = $walk->next( shift @neworder );
    }
    $walk->next(undef) if $walk;
}

# the topmost container with a message attached
sub topmost {
    my $self = shift;

    return $self if $self->message;
    my $sib = eval { $self->next->topmost };
    return $sib if $sib;
    my $kid = eval { $self->child->topmost };
    return $kid if $kid;
    return;
}

sub find_message_id {
    my $self = shift;
    my $id = shift;

    return $self if $self->id eq $id;
    for ( qw( child next ) ) {
        my $next = $self->$_();
        next unless $next;
        $next = $next->find_message_id($id);
        return $next if $next;
    }
    return;
}

package Message;
use Mail::Internet;
use Digest::MD5 qw(md5_base64);

use base qw(Mail::Internet);

sub filename {
    my $self = shift;
    my $foo = md5_base64( $self->as_string ).".html";
    $foo =~ tr{/}{_}; # slashes aren't a good idea (yes we're possibly
                      # introducing collisions)
    $foo;
}

sub subject {
    my $self = shift;
    $self->head->get('subject');
}

sub references {
    my $self = shift;
    $self->head->replace('references', @_) if @_;
    $self->head->get('references');
}

sub in_reply_to {
    my $self = shift;
    $self->head->replace('in-reply-to', @_) if @_;
    $self->head->get('in-reply-to');
}

sub date {
    my $self = shift;
    $self->head->get('date');
}

sub from {
    my $self = shift;
    my $from = $self->head->get('from');
    $from =~ s/<.*>//;
    $from =~ s/\@\S+//;
    $from;
}
