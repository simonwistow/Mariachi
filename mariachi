#!/usr/local/bin/perl -w
use strict;
use Template;
use Time::HiRes qw( gettimeofday tv_interval );
use Data::Dumper;

my $start = [gettimeofday];

my $maildir = shift || die "need an input maildir";
my $output = shift || die "where do we put them?";

my @mails = do {
    local $/;
    map {
        open my $fh, "<$_" or die "open: '$_' $!";
        Message->new(<$fh>);
    } <$maildir/cur/*>, <$maildir/new/*>;
};

# some messages have been near mail2news gateways, which means that
# some message ids get munged like so: <$group/$message_id>

# this should clean that up
my %names;
for my $mail (@mails) {
    for (qw( references in_reply_to )) {
        my $hdr = $mail->$_() or next;
        my $before = $hdr;
        $hdr =~ s{<[^>]*?/}{<}g or next;
        #print "$_ $before$_: $hdr";
        $mail->$_($hdr);
    }
}

print scalar @mails, " messages loaded in ", tv_interval( $start )," seconds\n";
$start = [gettimeofday];

my $threader = Email::Thread::Mariachi->new( @mails );
$threader->thread;

$_->order_children for $threader->rootset;

# Mail::Thread (in)sanity test
if (1) {
    my %mails = map { $_ => 1 } @mails;
    $_->recurse_down( sub { delete $mails{ $_[0]->message || '' } } ) for $threader->rootset;
    die "Didn't see ".Dumper [ keys %mails ]
      if %mails;
}

print "and threaded in ", tv_interval( $start ), " seconds\n";

$start = [gettimeofday];

my $tt = Template->new( RECURSION => 1 );


$tt->process('index.tt2',
             { threads => [ $threader->sorted_rootset ] },
             "$output/index.html") or die $tt->error;

# tt (in) sanity test
if (0) {
    my @unwalked = grep { !$_->walkedover } @mails;
    my @ids = map { [ $_->header('message-id'), $_->from, $_->subject ] } @unwalked;
    die "Didn't walk over ".(Dumper \@ids) . @ids . " messages"
      if @ids;
}

for my $mail (@mails) {
    $tt->process('message.tt2',
                 { thread  => find_root_thread($threader, $mail),
                   message => $mail,
                   headers => [ 'Subject', 'Date' ],
                 },
                 "$output/".$mail->filename) or die $tt->error;
}

print "output generation took ", tv_interval( $start ), " seconds\n";

exit 0;

# given a message, find the root of the thread that it's in
sub find_root_thread {
    my $self = shift;
    my $mail = shift;
    my $id   = $self->_msgid($mail);
    for my $cont ($self->rootset) {
        my $in;
        $cont->recurse_down( sub { $_[0]->messageid eq $id and $in = 1 } );
        return $cont if $in;
    }
}

package Email::Thread::Mariachi;
use Email::Thread (); # Ensure the module is actually installed and loaded.
use base 'Email::Thread';
use Date::Parse qw(str2time);

sub _container_class { "Email::Thread::Container::Mariachi" }

sub sorted_rootset {
    my $self = shift;
    _sort( $self->rootset );
}

sub _sort {
    return map {
        $_->[0]
    } sort {
        $a->[1] <=> $b->[1]
    } map {
        [ $_ => eval { str2time $_->topmost->message->date } || 0 ]
    } @_;
}

package Email::Thread::Container::Mariachi;
use base 'Email::Thread::Container';

sub order_children {
    my $self = shift;

    # go depth first
    eval { $self->child->order_children };
    eval { $self->next->order_children };

    my @children = $self->children;
    return if @children < 2;

    my @neworder = Email::Thread::Mariachi::_sort( @children );
    my $walk = $self->child( shift @neworder );
    while (@neworder) { $walk = $walk->next( shift @neworder ) }
    $walk->next(undef) if $walk;
}

package Message;
use Email::Simple;
use Class::Accessor::Fast;
use Digest::MD5 qw(md5_base64);

use base qw(Email::Simple Class::Accessor::Fast);
BEGIN { Message->mk_accessors(qw(filename from walkedover)) };

sub subject { $_[0]->header('subject') }
sub date    { $_[0]->header('date') }

sub new {
    my $class = shift;
    my $source = shift;
    my $self = $class->SUPER::new($source) or return;

    my $filename = md5_base64( $source ).".html";
    $filename =~ tr{/+}{_-}; # + isn't as portably safe as -
    # This isn't going to create collisions as the 64 characters used are:
    # ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/
    $self->filename($filename);

    # from is a sanitised mail address
    my $from = $self->header('from');
    $from =~ s/<.*>//;
    $from =~ s/\@\S+//;
    $from =~ s/\s+\z//;
    $self->from($from);

    return $self;
}

sub references {
    my $self = shift;
    @_ ? $self->header_set('references', @_) : $self->header('references');
}

sub in_reply_to {
    my $self = shift;
    @_ ? $self->header_set('in-reply-to', @_) : $self->header('in-reply-to');
}

